= Cloud Native
:sectnums:
:toc: left

유 미 (takytaky@empas.com)

== 실습 환경 설정하기

. virtualbox 프로그램 설치 
. oracle virtualbox extension pack 설치 
. 가상 머신 가져오기(import)  ubuntu18.04
. 가상머신 통신 (네트워크 연결 상태 확인) 
. ssh 를 사용해서 linux(ubuntu) root 사용자로 로그인 허용 
[source, bash]
$ sudo gedit /etc/ssh/sshd_config
[sudo] password for worker1: ubuntu 
	#PermitRootLogin prohibit-password 
		--> PermitRootLogin yes 
$ sudo systemctl restart sshd 
$ ip addr 
	enp0s3 inet 192.168.137.101
	
. putty 터미널 사용연결 
[source, bash]
# cat  /etc/os-release 
	--> 실습 리눅스 버전 확인 

== 컨테이너 기반 기술 
=== chroot 실습 
[source, bash]
pwd (present working directory) : 사용자 현재 작업 디렉토리 확인 
mkdir (make directory) : 디렉토리 생성 
ls ( list ) : 디렉토리 목록 확인 

[source, bash]
 mkdir -p /root/newroot/{bin,lib,lib64}
 ls 
 apt install tree   (apt : advanced package tool,  패키지 설치 ) 
 tree .
 chroot  /root/newroot   /bin/bash 

[source, bash]
/   <------  /root/newroot
/bin/bash <----  /root/newroot/bin/bash 

[source, bash]
 cp /bin/bash    /root/newroot/bin/bash
 cp /bin/ls  /root/newroot/bin/ls
 mkdir /root/newroot/lib/x86_64-linux-gnu

[source, bash]
 cp  /lib/x86_64-linux-gnu/libtinfo.so.5   /root/newroot/lib/x86_64-linux-gnu/libtinfo.so.5
 cp /lib/x86_64-linux-gnu/libdl.so.2  /root/newroot/lib/x86_64-linux-gnu/libdl.so.2
 cp /lib/x86_64-linux-gnu/libc.so.6  /root/newroot/lib/x86_64-linux-gnu/libc.so.6
 cp /lib64/ld-linux-x86-64.so.2  /root/newroot/lib64/ld-linux-x86-64.so.2

[source, bash]
 cp /lib/x86_64-linux-gnu/libselinux.so.1  /root/newroot/lib/x86_64-linux-gnu/libselinux.so.1
 cp /lib/x86_64-linux-gnu/libc.so.6  /root/newroot/lib/x86_64-linux-gnu/libc.so.6
 cp /lib/x86_64-linux-gnu/libpcre.so.3 /root/newroot/lib/x86_64-linux-gnu/libpcre.so.3
 cp /lib/x86_64-linux-gnu/libdl.so.2  /root/newroot/lib/x86_64-linux-gnu/libdl.so.2
 cp /lib64/ld-linux-x86-64.so.2  /root/newroot/lib64/ld-linux-x86-64.so.2
 cp /lib/x86_64-linux-gnu/libpthread.so.0  /root/newroot/lib/x86_64-linux-gnu/libpthread.so.0

[source, bash]
 tree .
 chroot  /root/newroot   /bin/bash 

[source, bash]
su ( switch user ) : 사용자 전환/변경 
bash (shell) : 사용자에게 명령어 입력 프롬프트 출력 입력 
 ip netns del guestnet

=== Namespaces


=== Cgroups 실습 

[source, bash]
tar -zxvf docker_lab.tgz
term 2 # top   ( CPU많이 사용하는 순으로 프로세스를 정렬 출력)

[source, bash]
term 1#  cd docker_lab
term 1#  ./a.out & 
term 1#  ./b.out & 
term 1# cd /sys/fs/cgroup/cpu
term 1# mkdir limit_50_percent 
term 1# cd limit_50_percent 
term 1# echo 3661 > tasks

[source, bash]
term1 # echo $(pgrep a.out) > tasks
term 1# cat tasks 
term 1# echo 512 > cpu.shares

[source, bash]
자원의 경쟁(경합) 가중치 
a.out   b.out 
1024  1024 
1 (50%)    :     1  (50%)
term 1# pkill b.out 
term 1# pkill a.out 

=== Overlay 실습 

[source, bash]
mkdir overlayfs
cd overlayfs
mkdir container image1 image2 image3 work merge

[source, bash]
echo Hello, world > image1/a
echo Hello, docker > image1/b
echo Hello, yumi > image2/c
mount -t overlay  overlay -o lowerdir=image2:image1,upperdir=container,workdir=work    merge

[source, bash]
cat merge/a
Hello, world
cat merge/b
Hello, docker
cat merge/c
Hello, yumi
echo Good bye > merge/a
cat merge/a
Good by

[source, bash]
echo Good night > merge/d
rm merge/b

== Docker
=== Installation
==== using script
[source, bash]
curl -fsSL https://get.docker.com -o install.sh
less install.sh
chmod +x install.sh 
install.sh 

==== using apt-get
[source, bash]
uname -r #check the version
cat /etc/os-release
NAME="Ubuntu"
VERSION="18.04.5 LTS (Bionic Beaver)"

[source, bash]
apt-get update    
sudo apt-get install -y  apt-transport-https ca-certificates curl software-properties-common
https를 사용해서 레포지토리를 사용할 수 있도록 필요한 패키지를 설치한다. 
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
Docker 공식 리포지토리에서 패키지를 다운로드 받았을때 위변조 확인을 위한 GPG 키를 추가한다.
apt-key fingerprint
/etc/apt/trusted.gpg
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) <docker@docker.com>
sub   rsa4096 2017-02-22 [S]
Docker.com 의 GPG 키가 등록됐는지 확인한다. 
add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
Docker 공식 저장소를 리포지토리로 등록한다.
grep docker /etc/apt/sources.list
deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable
저장소 등록정보에 기록됐는지 확인한다. 
apt-get update    
리포지토리 정보를 갱신
apt-get install -y docker-ce
docker container engine 을 설치한다.

[source, bash]
vim /etc/apt/sources.list #오타 수정 

=== Managing Docker Service
[source, bash]
systemctl status docker 
systemctl enable docker  --> docker 를 시스템 부팅 시 자동 실행 
systemctl restart docker 
systemctl stop docker 
systemctl start docker 

=== Running Container
==== Interactive
[source, bash]
docker container run -it --name c1 centos /bin/ping localhost

==== Detached
[source, bash]
docker container run -d --name web httpd
docker container logs web
docker container exec -it web /bin/bash

[source, bash]
docker container inspect web | grep IPAddr
curl -sf http://172.17.0.3

==== Copy
[source, bash]
docker container cp hostfile  test00:/containerfile
docker container exec test00  cat /containerfile
docker container cp test00:/containerfile    hostfile

==== 모든컨테이너 일괄 삭제하기 
[source, bash]
alias conrm='docker container rm -f $(docker container ps -aq)'

==== docker container diff 실습
[source, bash]
docker container run -it --name test01  centos
docker container inspect test01 | grep -C2 UpperDir

==== Volume


==== Networking
[source, bash]
docker container run -d --name web1 -p 8080:80 nginx
docker container run -d --name web2 -p 8181:80 nginx

[source, bash]
docker container inspect web1 | grep IPAddr
                  "IPAddress": "172.17.0.2",
docker container inspect web2 | grep IPAddr
                  "IPAddress": "172.17.0.3",

[source, bash]
echo "This is web1 server" > index.html
docker container cp index.html  web1:/usr/share/nginx/html/index.html

[source, bash]
echo "This is web2 server" > index.html
docker container cp index.html web2:/usr/share/nginx/html/index.html

[source, bash]
curl -sf http://172.17.0.2
This is web1 server
This is web2 server

[source, bash]
web browser 
http://192.168.137.101:8080
http://192.168.137.101:8080

[source, bash]
docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
5db7f0b30b02   bridge    bridge    local
515d21ee2b86   host      host      local
fc133b3066a6   none      null      local

[source, bash]
docker network inspect bridge

[source, bash]
docker container run -it --name host00 --net host centos
docker container run -it --name none00 --net none centos

=== Image Management
==== Push
[source, bash]
docker login
docker image tag busybox jonggun/busyimage:1.0 
docker image push jonggun/busyimage:1.0 
docker image rm jonggun/busyimage:1.0 
docker logout

==== Creating images from containers
[source, bash]
docker rm -f $(docker ps -aq)
echo Hello, World > index.html
docker run -it --name sample ubuntu
touch /data.out
ctrl+PQ
docker container cp index.html sample:/usr/share/nginx/index.html
docker container commit -a "Comment" -m "message" sample jonggun/web00:1.0
docker run -it --name test jonggun/web00:1.0

==== Creating Images from script
[source, bash]
 cd 
 tar -zxvf docker_lab.tgz 
 cd docker_lab/dockerfile_dir 
 pwd
/root/docker_lab/dockerfile_dir
 cat Dockerfile.1 
FROM ubuntu
RUN  apt-get update && apt-get install -y -q nginx
COPY index.html /var/www/html/
CMD ["nginx", "-g", "daemon off; " ]
docker build -t web00:1.0 -f Dockerfile.1  .
docker image ls

[source, bash]
nano Dockerfile.1
FROM ubuntu
RUN  apt-get update && apt-get install -y -q nginx && rm -rf  /var/lib/apt/lists/*
COPY index.html /var/www/html/
CMD ["nginx", "-g", "daemon off; " ]

[source, bash]
docker build -t web00:2.0 -f Dockerfile.1  .
docker image ls 
docker image inspect centos 

[source, bash]
nano Dockerfile.7 
 FROM centos:7
 ENV myName “Yu Mi”
 ENV myOrder Pizza Pasta Salad
 ENV myNumber 1004
docker build -t env00 -f Dockerfile.7 .     
docker run -it env00
	[root@e251996adf58 /]# env
[source, bash]
nano Dockerfile.10
FROM centos:7
LABEL maintainer "Yu Mi <yumi@example.com>"
LABEL title "TEST Image"
LABEL version 1.0
LABEL description "This image is test image ^__^"

[source, bash]
docker build -t label00 -f Dockerfile.10  .
docker image inspect label00

[source, bash]
cat Dockerfile.11
FROM nginx
EXPOSE 443
docker build -t port00 -f Dockerfile.11 .
docker run -d -p 8080:443 port00
docker ps -a

[source, bash]
cat Dockerfile.13
FROM ubuntu
ADD host.html  /first_dir/
ADD host.html  /first_dir/secondfile
ADD https://github.com/kubernetes/kubernetes/blob/master/LICENSE /first_dir/
ADD webdata.tar /first_dir/
docker build -t add00 -f Dockerfile.13 .
docker run -it add00 

[source, bash]
cat Dockerfile.15
FROM ubuntu
VOLUME /container
docker build -t volume00 -f Dockerfile.15 .
docker run -it volume00
docker ps -a
docker container inspect admiring_black
        "Mounts": [
            {
                "Type": "volume",
                "Name": "7a03c4dacae697515069000c969e426e68013c0a782d9e0f6c3ab10a12682016",
                "Source": "/var/lib/docker/volumes/7a03c4dacae697515069000c969e426e68013c0a782d9e0f6c3ab10a12682016/_data",
                "Destination": "/container",
                "Driver": "local",

== Kubernetes
=== Installation
==== Check & Set Environment
[source, bash]
free  : 메모리(RAM)  사이즈 확인 
cat /proc/cpuinfo : cpu core 수 확인 
hostnamectl set-hostname  master
hostname
nano  /etc/hosts 
	192.168.137.101     master 
	192.168.137.102     worker1 
	192.168.137.103	worker2
docker rm -f $(docker ps -aq)
poweroff

==== Fixed IP
[source, bash]
hostnamctl set-hostname  worker1
hostname 
cd /etc/netplan
nano 00-installer-config.yaml
	192.168.137.101  ---> 192.168.137.102
 netplan apply 

== Useful Unix Commands
[source, bash]
watch -n 1 docker container ps -a