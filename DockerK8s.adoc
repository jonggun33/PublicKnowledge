= Cloud Native

유 미 (takytaky@empas.com)

== 실습 환경 설정하기

. virtualbox 프로그램 설치 
. oracle virtualbox extension pack 설치 
. 가상 머신 가져오기(import)  ubuntu18.04
. 가상머신 통신 (네트워크 연결 상태 확인) 
. ssh 를 사용해서 linux(ubuntu) root 사용자로 로그인 허용 
[source, bash]
$ sudo gedit /etc/ssh/sshd_config
[sudo] password for worker1: ubuntu 
	#PermitRootLogin prohibit-password 
		--> PermitRootLogin yes 
$ sudo systemctl restart sshd 
$ ip addr 
	enp0s3 inet 192.168.137.101
	
. putty 터미널 사용연결 
[source, bash]
# cat  /etc/os-release 
	--> 실습 리눅스 버전 확인 

== 컨테이너 기반 기술 
=== chroot 실습 
[source, bash]
pwd (present working directory) : 사용자 현재 작업 디렉토리 확인 
mkdir (make directory) : 디렉토리 생성 
ls ( list ) : 디렉토리 목록 확인 

[source, bash]
 mkdir -p /root/newroot/{bin,lib,lib64}
 ls 
 apt install tree   (apt : advanced package tool,  패키지 설치 ) 
 tree .
 chroot  /root/newroot   /bin/bash 

[source, bash]
/   <------  /root/newroot
/bin/bash <----  /root/newroot/bin/bash 

[source, bash]
 cp /bin/bash    /root/newroot/bin/bash
 cp /bin/ls  /root/newroot/bin/ls
 mkdir /root/newroot/lib/x86_64-linux-gnu

[source, bash]
 cp  /lib/x86_64-linux-gnu/libtinfo.so.5   /root/newroot/lib/x86_64-linux-gnu/libtinfo.so.5
 cp /lib/x86_64-linux-gnu/libdl.so.2  /root/newroot/lib/x86_64-linux-gnu/libdl.so.2
 cp /lib/x86_64-linux-gnu/libc.so.6  /root/newroot/lib/x86_64-linux-gnu/libc.so.6
 cp /lib64/ld-linux-x86-64.so.2  /root/newroot/lib64/ld-linux-x86-64.so.2

[source, bash]
 cp /lib/x86_64-linux-gnu/libselinux.so.1  /root/newroot/lib/x86_64-linux-gnu/libselinux.so.1
 cp /lib/x86_64-linux-gnu/libc.so.6  /root/newroot/lib/x86_64-linux-gnu/libc.so.6
 cp /lib/x86_64-linux-gnu/libpcre.so.3 /root/newroot/lib/x86_64-linux-gnu/libpcre.so.3
 cp /lib/x86_64-linux-gnu/libdl.so.2  /root/newroot/lib/x86_64-linux-gnu/libdl.so.2
 cp /lib64/ld-linux-x86-64.so.2  /root/newroot/lib64/ld-linux-x86-64.so.2
 cp /lib/x86_64-linux-gnu/libpthread.so.0  /root/newroot/lib/x86_64-linux-gnu/libpthread.so.0

[source, bash]
 tree .
 chroot  /root/newroot   /bin/bash 

[source, bash]
su ( switch user ) : 사용자 전환/변경 
bash (shell) : 사용자에게 명령어 입력 프롬프트 출력 입력 
 ip netns del guestnet

=== Cgroups 실습 

[source, bash]
tar -zxvf docker_lab.tgz
term 2 # top   ( CPU많이 사용하는 순으로 프로세스를 정렬 출력)

[source, bash]
term 1#  cd docker_lab
term 1#  ./a.out & 
term 1#  ./b.out & 
term 1# cd /sys/fs/cgroup/cpu
term 1# mkdir limit_50_percent 
term 1# cd limit_50_percent 
term 1# echo 3661 > tasks

[source, bash]
term1 # echo $(pgrep a.out) > tasks
term 1# cat tasks 
term 1# echo 512 > cpu.shares

[source, bash]
자원의 경쟁(경합) 가중치 
a.out   b.out 
1024  1024 
1 (50%)    :     1  (50%)
term 1# pkill b.out 
term 1# pkill a.out 

=== Overlay 실습 

[source, bash]
mkdir overlayfs
cd overlayfs
mkdir container image1 image2 image3 work merge

[source, bash]
echo Hello, world > image1/a
echo Hello, docker > image1/b
echo Hello, yumi > image2/c
mount -t overlay  overlay -o lowerdir=image2:image1,upperdir=container,workdir=work    merge

[source, bash]
cat merge/a
Hello, world
cat merge/b
Hello, docker
cat merge/c
Hello, yumi
echo Good bye > merge/a
cat merge/a
Good by

[source, bash]
echo Good night > merge/d
rm merge/b

== Docker
=== Installation
==== using script
[source, bash]
curl -fsSL https://get.docker.com -o install.sh
less install.sh
chmod +x install.sh 
install.sh 

==== using apt-get
[source, bash]
uname -r #check the version
cat /etc/os-release
NAME="Ubuntu"
VERSION="18.04.5 LTS (Bionic Beaver)"

[source, bash]
apt-get update    
sudo apt-get install -y  apt-transport-https ca-certificates curl software-properties-common
https를 사용해서 레포지토리를 사용할 수 있도록 필요한 패키지를 설치한다. 
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
Docker 공식 리포지토리에서 패키지를 다운로드 받았을때 위변조 확인을 위한 GPG 키를 추가한다.
apt-key fingerprint
/etc/apt/trusted.gpg
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) <docker@docker.com>
sub   rsa4096 2017-02-22 [S]
Docker.com 의 GPG 키가 등록됐는지 확인한다. 
add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
Docker 공식 저장소를 리포지토리로 등록한다.
grep docker /etc/apt/sources.list
deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable
저장소 등록정보에 기록됐는지 확인한다. 
apt-get update    
리포지토리 정보를 갱신
apt-get install -y docker-ce
docker container engine 을 설치한다.

[source, bash]
vim /etc/apt/sources.list #오타 수정 

=== Managing Docker Service
[source, bash]
systemctl status docker 
systemctl enable docker  --> docker 를 시스템 부팅 시 자동 실행 
systemctl restart docker 
systemctl stop docker 
systemctl start docker 

=== Running Container
==== Interactive
[source, bash]
docker container run -it --name c1 centos /bin/ping localhost

==== Detached
[source, bash]
docker container run -d --name web httpd
docker container logs web
docker container exec -it web /bin/bash

[source, bash]
docker container inspect web | grep IPAddr
curl -sf http://172.17.0.3

==== Copy
[source, bash]
docker container cp hostfile  test00:/containerfile
docker container exec test00  cat /containerfile
docker container cp test00:/containerfile    hostfile

==== 모든컨테이너 일괄 삭제하기 
[source, bash]
alias conrm='docker container rm -f $(docker container ps -aq)'

==== docker container diff 실습
[source, bash]
docker container run -it --name test01  centos
docker container inspect test01 | grep -C2 UpperDir

==== Networking
[source, bash]
======================
docker container run -d --name web1 -p 8080:80 nginx
docker container run -d --name web2 -p 8181:80 nginx

docker container inspect web1 | grep IPAddr
                  "IPAddress": "172.17.0.2",

docker container inspect web2 | grep IPAddr
                  "IPAddress": "172.17.0.3",

echo "This is web1 server" > index.html
docker container cp index.html  web1:/usr/share/nginx/html/index.html

echo "This is web2 server" > index.html
docker container cp index.html web2:/usr/share/nginx/html/index.html

curl -sf http://172.17.0.2
This is web1 server
This is web2 server

web browser 
http://192.168.137.101:8080
http://192.168.137.101:8080

docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
5db7f0b30b02   bridge    bridge    local
515d21ee2b86   host      host      local
fc133b3066a6   none      null      local

docker network inspect bridge

docker container run -it --name host00 --net host centos
docker container run -it --name none00 --net none centos
======================

== Useful Unix Commands
[source, bash]
watch -n 1 docker container ps -a




